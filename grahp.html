<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>心の折れ線グラフ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
            color: #2d3748;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2.5rem;
            max-width: 900px;
            width: 100%;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 60%; /* 16:9 Aspect Ratio */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center p-4">

    <div class="container mx-auto p-8 bg-white rounded-3xl shadow-xl max-w-4xl">
        <h1 class="text-3xl font-bold text-center mb-6 text-gray-800">心の折れ線グラフ</h1>
        <p class="text-center text-gray-600 mb-8">
            グラフ上の点をクリックしてドラッグすると、グラフの形を変えることができます。
        </p>

        <div class="canvas-container">
            <canvas id="graphCanvas"></canvas>
        </div>

        <div class="mt-8 flex flex-wrap justify-center sm:justify-between items-center text-center text-gray-600">
            <div class="flex items-center mx-2 my-1 sm:my-0">
                <span class="inline-block w-4 h-4 rounded-full bg-red-500 mr-2"></span>
                <span>しあわせ</span>
            </div>
            <div class="flex items-center mx-2 my-1 sm:my-0">
                <span class="inline-block w-4 h-4 rounded-full bg-blue-500 mr-2"></span>
                <span>ふしあわせ</span>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');

            // padding変数をグローバルスコープで定義
            const padding = 20;

            const numSections = 9;
            let happinessData = [];
            let unhappinessData = [];
            let isDragging = false;
            let draggingPoint = null; // { type: 'happiness' or 'unhappiness', index: number }

            const resizeCanvas = () => {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                drawGraph();
            };

            const generateRandomData = () => {
                happinessData = Array.from({ length: numSections + 1 }, () => Math.random());
                unhappinessData = Array.from({ length: numSections + 1 }, () => Math.random());
            };

            const drawGraph = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Define dimensions
                const graphWidth = canvas.width - padding * 2;
                const graphHeight = canvas.height - padding * 2;
                const xOffset = padding;
                const yOffset = padding;

                // Draw background grid lines
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const y = yOffset + graphHeight * (i / 10);
                    ctx.beginPath();
                    ctx.moveTo(xOffset, y);
                    ctx.lineTo(xOffset + graphWidth, y);
                    ctx.stroke();
                }
                
                // Draw lines and points
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                
                // Draw happiness line
                ctx.strokeStyle = '#ef4444'; // red-500
                ctx.beginPath();
                ctx.moveTo(xOffset + graphWidth * (0 / numSections), yOffset + graphHeight * (1 - happinessData[0]));
                for (let i = 1; i <= numSections; i++) {
                    const x = xOffset + graphWidth * (i / numSections);
                    const y = yOffset + graphHeight * (1 - happinessData[i]);
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw unhappiness line
                ctx.strokeStyle = '#3b82f6'; // blue-500
                ctx.beginPath();
                ctx.moveTo(xOffset + graphWidth * (0 / numSections), yOffset + graphHeight * (1 - unhappinessData[0]));
                for (let i = 1; i <= numSections; i++) {
                    const x = xOffset + graphWidth * (i / numSections);
                    const y = yOffset + graphHeight * (1 - unhappinessData[i]);
                    ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw points on the lines
                ctx.fillStyle = '#ef4444';
                for (let i = 0; i <= numSections; i++) {
                    const x = xOffset + graphWidth * (i / numSections);
                    const y = yOffset + graphHeight * (1 - happinessData[i]);
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = '#3b82f6';
                for (let i = 0; i <= numSections; i++) {
                    const x = xOffset + graphWidth * (i / numSections);
                    const y = yOffset + graphHeight * (1 - unhappinessData[i]);
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw labels on the right y-axis
                ctx.fillStyle = '#2d3748';
                ctx.font = '16px Inter';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText('しあわせ', xOffset + graphWidth + 10, yOffset + graphHeight * 0.1);
                ctx.fillText('ふしあわせ', xOffset + graphWidth + 10, yOffset + graphHeight * 0.9);

                // Draw time labels at the bottom
                ctx.textAlign = 'center';
                for (let i = 0; i <= numSections; i++) {
                    const x = xOffset + graphWidth * (i / numSections);
                    ctx.fillText(`${i}日目`, x, yOffset + graphHeight + 15);
                }
            };

            const getMousePos = (e) => {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            };

            canvas.addEventListener('mousedown', (e) => {
                const mousePos = getMousePos(e);
                const clickTolerance = 12;

                // Check happiness points
                for (let i = 0; i <= numSections; i++) {
                    const pointX = padding + (canvas.width - padding * 2) * (i / numSections);
                    const pointY = padding + (canvas.height - padding * 2) * (1 - happinessData[i]);
                    const dist = Math.sqrt(Math.pow(mousePos.x - pointX, 2) + Math.pow(mousePos.y - pointY, 2));
                    if (dist < clickTolerance) {
                        isDragging = true;
                        draggingPoint = { type: 'happiness', index: i };
                        return;
                    }
                }

                // Check unhappiness points
                for (let i = 0; i <= numSections; i++) {
                    const pointX = padding + (canvas.width - padding * 2) * (i / numSections);
                    const pointY = padding + (canvas.height - padding * 2) * (1 - unhappinessData[i]);
                    const dist = Math.sqrt(Math.pow(mousePos.x - pointX, 2) + Math.pow(mousePos.y - pointY, 2));
                    if (dist < clickTolerance) {
                        isDragging = true;
                        draggingPoint = { type: 'unhappiness', index: i };
                        return;
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || !draggingPoint) return;

                const mousePos = getMousePos(e);
                const graphHeight = canvas.height - padding * 2;
                const newYValue = 1 - ((mousePos.y - padding) / graphHeight);
                const clampedYValue = Math.max(0, Math.min(1, newYValue));

                if (draggingPoint.type === 'happiness') {
                    happinessData[draggingPoint.index] = clampedYValue;
                } else {
                    unhappinessData[draggingPoint.index] = clampedYValue;
                }

                drawGraph();
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                draggingPoint = null;
            });
            
            // For touch devices
            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const mousePos = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                const clickTolerance = 12;

                // Check happiness points
                for (let i = 0; i <= numSections; i++) {
                    const pointX = padding + (canvas.width - padding * 2) * (i / numSections);
                    const pointY = padding + (canvas.height - padding * 2) * (1 - happinessData[i]);
                    const dist = Math.sqrt(Math.pow(mousePos.x - pointX, 2) + Math.pow(mousePos.y - pointY, 2));
                    if (dist < clickTolerance) {
                        isDragging = true;
                        draggingPoint = { type: 'happiness', index: i };
                        return;
                    }
                }

                // Check unhappiness points
                for (let i = 0; i <= numSections; i++) {
                    const pointX = padding + (canvas.width - padding * 2) * (i / numSections);
                    const pointY = padding + (canvas.height - padding * 2) * (1 - unhappinessData[i]);
                    const dist = Math.sqrt(Math.pow(mousePos.x - pointX, 2) + Math.pow(mousePos.y - pointY, 2));
                    if (dist < clickTolerance) {
                        isDragging = true;
                        draggingPoint = { type: 'unhappiness', index: i };
                        return;
                    }
                }
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                if (!isDragging || !draggingPoint) return;
                e.preventDefault(); // Prevent default scroll
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const mousePos = {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
                const graphHeight = canvas.height - padding * 2;
                const newYValue = 1 - ((mousePos.y - padding) / graphHeight);
                const clampedYValue = Math.max(0, Math.min(1, newYValue));

                if (draggingPoint.type === 'happiness') {
                    happinessData[draggingPoint.index] = clampedYValue;
                } else {
                    unhappinessData[draggingPoint.index] = clampedYValue;
                }

                drawGraph();
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
                draggingPoint = null;
            });
            
            window.addEventListener('resize', resizeCanvas);

            // Initial setup
            generateRandomData();
            resizeCanvas();
        });
    </script>
</body>
</html>
